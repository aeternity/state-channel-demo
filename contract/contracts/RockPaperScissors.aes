include "String.aes"
include "Option.aes"

payable contract CoinToss =
  datatype move = Paper | Rock | Scissors

  record state = { player0         : address
                 , player1         : address
                 , hash            : option(hash)
                 , height          : int
                 , player1_move    : option(move)
                 , stake           : int
                 , reaction_time   : int
                 , debug_timestamp : option(int)
                 }
  datatype event
    = Init                (address  /*player0*/     , address /*player1*/     , int /*reaction_time*/      )
    | Player0Won          (address  /*player0*/     , int     /*amount won*/                               )
    | Player1Won          (address  /*player1*/     , int     /*amount won*/                               )
    | Draw                (int      /*player0 won*/ , int     /*player1 won*/ , string /*player0|player1*/ )
    | Player0ProvidedHash (hash     /*hash*/        , int     /*stake*/                                    )
    | Player0Revealed     (string   /*move*/                                                               )
    | Player1Moved        (string   /*move*/        , int     /*state*/                                    )
    | Player0WonDispute   (address  /*player0*/     , int     /*stake*/                                    )
    | Player1WonDispute   (address  /*player1*/     , int     /*stake*/                                    )

  entrypoint get_state() = state

  entrypoint init(player0: address, player1: address, reaction_time: int,debug_timestamp: option(int)) : state =
    require(player0 != player1,"use different addresses")
    require(Call.value == 0, "no_deposit")
    Chain.event(Init(player0,player1,reaction_time))
    {  player0         = player0
     , player1         = player1
     , hash            = None
     , height          = 0
     , player1_move    = None
     , stake           = 0
     , reaction_time   = reaction_time
     , debug_timestamp = debug_timestamp
     }

  payable stateful entrypoint provide_hash(hash: hash): unit =
    require_player0()
    require(state.hash == None, "already_has_hash")
    require(Call.value > 0, "no_stake")
    put(state{ hash = Some(hash),
               stake  = Call.value,
               height = get_timestamp()})
    Chain.event(Player0ProvidedHash(hash,Call.value))

  payable stateful entrypoint player1_move(move_str: string): unit =
    require_player1()
    ensure_player1_turn_to_move()
    let move = str_to_move(move_str)
    require(Call.value == state.stake,
      String.concat("wrong_stake, expected ", Int.to_str(state.stake)))
    put(state{ player1_move  = Some(move),
               height        = get_timestamp()})
    Chain.event(Player1Moved(move_str,Call.value))

  stateful entrypoint reveal(key: string, move_str: string): option(address) =
    require_player0()
    ensure_player0_turn_to_reveal()
    let player0_move = str_to_move(move_str)
    ensure_if_key_is_valid(key, move_str)
    let Some(player1_move) = state.player1_move
    //TODO:  get the winner
    let stake = state.stake
    Chain.event(Player0Revealed(move_str))
    reset_state()
    let (p0,p1) = (state.player0,state.player1)
    switch(get_winner(player0_move,player1_move))
        None =>
          let p0_refund = Contract.balance / 2
          Chain.spend( p0, p0_refund )
          let p1_refund = Contract.balance
          Chain.spend( p1, p1_refund) // send the rest of it
          Chain.event(Draw(p0_refund,p1_refund,
              String.concat(
                Address.to_str(p0),
                String.concat("|",Address.to_str(p1))
                )
            ))
          None
        Some(true) =>
          Chain.event(Player0Won(p0,Contract.balance))
          Chain.spend(p0, Contract.balance)
          Some(p0)
        _ =>
          Chain.event(Player1Won(p1,Contract.balance))
          Chain.spend(p1, Contract.balance)
          Some(p1)

  stateful entrypoint player1_dispute_no_reveal(): unit =
    require_player1()
    ensure_player0_turn_to_reveal()
    require(state.height  + state.reaction_time < get_timestamp(), "not_yet_allowed")
    Chain.event(Player1WonDispute(state.player1,Contract.balance))
    Chain.spend(state.player1, Contract.balance)
    reset_state()

  stateful entrypoint player0_dispute_no_move(): unit =
    require_player0()
    ensure_player1_turn_to_move()
    require(state.height + state.reaction_time < get_timestamp(), "not_yet_allowed")
    Chain.event(Player0WonDispute(state.player0,Contract.balance))
    Chain.spend(state.player0, Contract.balance)
    reset_state()

  entrypoint compute_hash(key: string, move: string) : hash =
    String.sha256(String.concat(key, move))

  //for debug / test purposes
  stateful entrypoint set_time_stamp(timestamp: int ): unit =
    require(state.debug_timestamp != None,"not in debug mode")
    put(state { debug_timestamp = Some(timestamp) })

  // internal functions
  function get_timestamp() = Option.default(Chain.timestamp,state.debug_timestamp)

  function ensure_player1_turn_to_move() =
    require(state.hash != None, "no_hash")
    require(state.player1_move == None, "there_is_a_move_already")

  function ensure_player0_turn_to_reveal() =
    require(state.player1_move != None, "there_is_no_move")

  function require_player1() =
    require(Call.caller == state.player1, "not_player1")

  function require_player0() =
    require(Call.caller == state.player0, "not_player0")

  function ensure_if_key_is_valid(key: string, move: string) =
    let computed_hash = compute_hash(key, move)
    let Some(stored_hash) = state.hash
    require(stored_hash == computed_hash, "invalid_key_and_answer")

  function
    move_to_str:(move)     => string
    move_to_str (Rock)     = "rock"
    move_to_str (Paper)    = "paper"
    move_to_str (Scissors) = "scissors"

  function
    str_to_move:(string)     => move
    str_to_move ("rock")     = Rock
    str_to_move ("paper")    = Paper
    str_to_move ("scissors") = Scissors
    str_to_move (_)          = abort("invalid_move")

  function
    get_winner:(move     , move)       => option(bool)
    get_winner (a        , b) | a == b = None
    get_winner (Rock     , Scissors)   = Some(true)
    get_winner (Scissors , Paper)      = Some(true)
    get_winner (Paper    , Rock)       = Some(true)
    get_winner (_        , _ )         = Some(false)

  stateful function reset_state() =
    put(state{hash            = None,
              height          = 0,
              player1_move     = None,
              stake           = 0
              })
