export const contractBytecode =
  'cb_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aW1lc3RhbXARPR6JaCVnZXRfc3RhdGURRNZEHxFpbml0EVFXpvkxY29tcHV0ZV9oYXNoEVjLtZKJLlJvY2tQYXBlclNjaXNzb3JzLnJlcXVpcmVfcGxheWVyMBFlpeAPLUNoYWluLmV2ZW50EWrApr7BLlJvY2tQYXBlclNjaXNzb3JzLmVuc3VyZV9wbGF5ZXIwX3R1cm5fdG9fcmV2ZWFsEXtiH9NdcGxheWVyMF9kaXNwdXRlX25vX21vdmURk0NDObkuUm9ja1BhcGVyU2Npc3NvcnMuZW5zdXJlX3BsYXllcjFfdHVybl90b19tb3ZlEagFMsAZcmV2ZWFsEauIMtE5LlN0cmluZy5jb25jYXQRtLEvhmVwbGF5ZXIxX2Rpc3B1dGVfbm9fcmV2ZWFsEcLTCMx5LlJvY2tQYXBlclNjaXNzb3JzLnN0cl90b19tb3ZlEcYWcVyJLlJvY2tQYXBlclNjaXNzb3JzLnJlcXVpcmVfcGxheWVyMRHJV7fPpS5Sb2NrUGFwZXJTY2lzc29ycy5lbnN1cmVfaWZfa2V5X2lzX3ZhbGlkEc5HFWA5LlN0cmluZy5zaGEyNTYRz7/qGnkuUm9ja1BhcGVyU2Npc3NvcnMucmVzZXRfc3RhdGUR6QHY/xkuXjEzMTQR78tQ7z0uT3B0aW9uLmRlZmF1bHSCLwCFNi4xLjABsLPzxw==';

export const contractSource = `
include "String.aes"
include "Option.aes"

payable contract RockPaperScissors =
  datatype move = Paper | Rock | Scissors

  record state = { player0             : address
                 , player1             : address
                 , hash                : option(hash)
                 , last_move_timestamp : int
                 , player1_move        : option(move)
                 , stake               : int
                 , reaction_time       : int
                 , debug_timestamp     : option(int)
                 }
  datatype event
    = Init                (address  /*player0*/     , address /*player1*/     , int /*reaction_time*/      )
    | Player0Won          (address  /*player0*/     , int     /*amount won*/                               )
    | Player1Won          (address  /*player1*/     , int     /*amount won*/                               )
    | Draw                (int      /*player0 won*/ , int     /*player1 won*/ , string /*player0|player1*/ )
    | Player0ProvidedHash (hash     /*hash*/        , int     /*stake*/                                    )
    | Player0Revealed     (string   /*move*/                                                               )
    | Player1Moved        (string   /*move*/        , int     /*state*/                                    )
    | Player0WonDispute   (address  /*player0*/     , int     /*stake*/                                    )
    | Player1WonDispute   (address  /*player1*/     , int     /*stake*/                                    )

  entrypoint get_state() = state

  entrypoint init(player0: address, player1: address, reaction_time: int, debug_timestamp: option(int)) : state =
    require(player0 != player1,"use_different_addresses")
    require(Call.value == 0, "no_deposit")
    Chain.event(Init(player0, player1, reaction_time))
    {  player0             = player0
     , player1             = player1
     , hash                = None
     , last_move_timestamp = 0
     , player1_move        = None
     , stake               = 0
     , reaction_time       = reaction_time
     , debug_timestamp     = debug_timestamp
     }

  payable stateful entrypoint provide_hash(hash: hash): unit =
    require_player0()
    require(state.hash == None, "already_has_hash")
    require(Call.value > 0, "no_stake")
    put(state { hash                = Some(hash)
              , stake               = Call.value
              , last_move_timestamp = get_timestamp()
              })
    Chain.event(Player0ProvidedHash(hash,Call.value))

  payable stateful entrypoint player1_move(move_str: string): unit =
    require_player1()
    ensure_player1_turn_to_move()
    let move = str_to_move(move_str)
    require(Call.value == state.stake,
      String.concat("wrong_stake, expected ", Int.to_str(state.stake)))
    put(state { player1_move        = Some(move)
              , last_move_timestamp = get_timestamp()
              })
    Chain.event(Player1Moved(move_str,Call.value))

  stateful entrypoint reveal(key: string, move_str: string): option(address) =
    require_player0()
    ensure_player0_turn_to_reveal()
    let player0_move = str_to_move(move_str)
    ensure_if_key_is_valid(key, move_str)
    let Some(player1_move) = state.player1_move
    let stake = state.stake
    Chain.event(Player0Revealed(move_str))
    reset_state()
    let (player0, player1) = (state.player0, state.player1)
    switch(get_winner(player0_move, player1_move))
        None =>
          let player0_refund = Contract.balance / 2
          Chain.spend(player0, player0_refund)
          let player1_refund = Contract.balance
          Chain.spend(player1, player1_refund) // send the rest of it
          Chain.event(Draw(player0_refund, player1_refund,
              String.concat(
                Address.to_str(player0),
                String.concat("|",Address.to_str(player1))
                )
            ))
          None
        Some(true) =>
          Chain.event(Player0Won(player0,Contract.balance))
          Chain.spend(player0, Contract.balance)
          Some(player0)
        Some(false) =>
          Chain.event(Player1Won(player1,Contract.balance))
          Chain.spend(player1, Contract.balance)
          Some(player1)

  stateful entrypoint player1_dispute_no_reveal(): unit =
    require_player1()
    ensure_player0_turn_to_reveal()
    ensure_reaction_time()
    Chain.event(Player1WonDispute(state.player1,Contract.balance))
    Chain.spend(state.player1, Contract.balance)
    reset_state()

  stateful entrypoint player0_dispute_no_move(): unit =
    require_player0()
    ensure_player1_turn_to_move()
    ensure_reaction_time()
    Chain.event(Player0WonDispute(state.player0,Contract.balance))
    Chain.spend(state.player0, Contract.balance)
    reset_state()

  entrypoint compute_hash(key: string, move: string) : hash =
    String.sha256(String.concat(key, move))

  function ensure_reaction_time() =
    require(state.last_move_timestamp + state.reaction_time < get_timestamp(), "not_yet_allowed")

  //for debug / test purposes
  stateful entrypoint set_timestamp(timestamp: int): unit =
    require(state.debug_timestamp != None,"not_debug_mode")
    require(timestamp >= 0,"not_positive")
    put(state { debug_timestamp = Some(timestamp) })

  // internal functions
  function get_timestamp() = Option.default(Chain.timestamp, state.debug_timestamp)

  function ensure_player1_turn_to_move() =
    require(state.hash != None, "no_hash")
    require(state.player1_move == None, "there_is_a_move_already")

  function ensure_player0_turn_to_reveal() =
    require(state.player1_move != None, "there_is_no_move")

  function require_player1() =
    require(Call.caller == state.player1, "not_player1")

  function require_player0() =
    require(Call.caller == state.player0, "not_player0")

  function ensure_if_key_is_valid(key: string, move: string) =
    let computed_hash = compute_hash(key, move)
    let Some(stored_hash) = state.hash
    require(stored_hash == computed_hash, "invalid_key_and_answer")

  function
    move_to_str:(move)     => string
    move_to_str (Rock)     = "rock"
    move_to_str (Paper)    = "paper"
    move_to_str (Scissors) = "scissors"

  function
    str_to_move:(string)     => move
    str_to_move ("rock")     = Rock
    str_to_move ("paper")    = Paper
    str_to_move ("scissors") = Scissors
    str_to_move (_)          = abort("invalid_move")

  function
    get_winner:(move     , move)       => option(bool)
    get_winner (a        , b) | a == b = None
    get_winner (Rock     , Scissors)   = Some(true)
    get_winner (Scissors , Paper)      = Some(true)
    get_winner (Paper    , Rock)       = Some(true)
    get_winner (_        , _)          = Some(false)

  stateful function reset_state() =
    put(state { hash                = None
              , last_move_timestamp = 0
              , player1_move        = None
              , stake               = 0
              })
`;
